// Generated by CoffeeScript 1.6.3
(function() {
  var Compiler, arrayCompiler, expressionCompiler, isArrayExpression, isString, joinArrays, pairSort, partition, prettyMap, terseMap, toString,
    __slice = [].slice;

  isString = function(s) {
    return '\'' === s[0] || '"' === s[0];
  };

  toString = function(s) {
    return s.slice(1, s.length - 1);
  };

  arrayCompiler = require('./class-array-expression-compiler');

  expressionCompiler = require('./class-expression-compiler');

  prettyMap = '  ' + "function map (obj, fn) {\n  if ('number' === typeof obj.length) return obj.map(fn);\n  var result = [], key, hasProp = {}.hasOwnProperty;\n  for (key in obj) hasProp.call(obj, key) && result.push(fn(key, obj[key]));\n  return result;\n}".split('\n').join('\n  ') + '\n\n';

  terseMap = "function map(o,f){if('number'===typeof o.length)return o.map(f);var r=[],k,h={}.hasOwnProperty;for(k in o)h.call(o,k)&&r.push(f(k,o[k]));return r;}";

  pairSort = function(a, b) {
    if (a[0] < b[0]) {
      return -1;
    } else if (a[0] > b[0]) {
      return 1;
    } else {
      return 0;
    }
  };

  partition = function(collection, fn) {
    var item, left, right, _i, _len;
    left = [];
    right = [];
    for (_i = 0, _len = collection.length; _i < _len; _i++) {
      item = collection[_i];
      if (fn(item)) {
        left.push(item);
      } else {
        right.push(item);
      }
    }
    return [left, right];
  };

  isArrayExpression = function(expression) {
    return '[' === expression[0] && ']' === expression[expression.length - 1];
  };

  joinArrays = function(expression) {
    if (isArrayExpression(expression)) {
      return expression + '.join(" ")';
    } else {
      return expression;
    }
  };

  Compiler = function(node, options) {
    return {
      compile: function() {
        var bufferExpression, continueIndenting, depth, indentToDepth, needsMap, normalizeAttributes, normalizeClassExpressions, parts, pretty, seenDepth0, toPush, visit, visitArgs, visitAttributes, visitBlock, visitCode, visitEach, visitNodes, visitTag, visitText;
        pretty = options.pretty;
        depth = -1;
        seenDepth0 = false;
        parts = [];
        seenDepth0 = false;
        needsMap = false;
        continueIndenting = false;
        visitTag = function(tag) {
          var anyArgs;
          bufferExpression(indentToDepth());
          bufferExpression('m("', tag.name, '",');
          visitAttributes(tag.attrs, tag.attributeBlocks);
          depth += 1;
          if (0 === depth && seenDepth0) {
            throw new Error('Component may have no more than one root node');
          }
          seenDepth0 = true;
          anyArgs = visitArgs(tag);
          depth -= 1;
          if (pretty) {
            if (anyArgs) {
              return bufferExpression('\n', indentToDepth(), ')');
            } else {
              return bufferExpression(')');
            }
          } else {
            return bufferExpression(')');
          }
        };
        visitArgs = function(node) {
          var anyArgs, i, len, _i, _len, _ref;
          len = node.block.nodes.length;
          anyArgs = node.code || len;
          if (anyArgs) {
            if (pretty) {
              bufferExpression(',\n');
            } else {
              bufferExpression(',');
            }
          }
          if (node.code) {
            visitCode(node.code);
          }
          _ref = node.block.nodes;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            node = _ref[i];
            visit(node);
            if (i + 1 < len) {
              if (pretty) {
                bufferExpression(',\n');
              } else {
                bufferExpression(',');
              }
            }
          }
          return anyArgs;
        };
        visitBlock = function(block) {
          var i, len, _i, _len, _ref, _results;
          len = block.nodes.length;
          _ref = block.nodes;
          _results = [];
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            node = _ref[i];
            visit(node);
            if (i + 1 < len) {
              _results.push(bufferExpression(' + \n'));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        normalizeClassExpressions = function(expressions) {
          var arrayExpressions, expression, stringClassNames, stringClassNamesExpression, stringExpressions, _i, _len, _ref, _ref1;
          _ref = partition(expressions, isArrayExpression), arrayExpressions = _ref[0], expressions = _ref[1];
          _ref1 = partition(expressions, isString), stringExpressions = _ref1[0], expressions = _ref1[1];
          stringClassNames = stringExpressions.map(toString);
          stringClassNamesExpression = JSON.stringify(stringClassNames.join(' '));
          if (stringClassNames.length) {
            expressions.unshift(stringClassNamesExpression);
          }
          if (arrayExpressions.length) {
            for (_i = 0, _len = arrayExpressions.length; _i < _len; _i++) {
              expression = arrayExpressions[_i];
              expressions.push(arrayCompiler(expression));
            }
          }
          if (1 === expressions.length) {
            expression = expressions[0];
          } else {
            expression = expressionCompiler(expressions.join('+" "+'));
          }
          return expression;
        };
        normalizeAttributes = function(attrs) {
          var attr, classExpressions, name, normalized, val, visited, _i, _len;
          visited = {};
          classExpressions = [];
          normalized = {};
          for (_i = 0, _len = attrs.length; _i < _len; _i++) {
            attr = attrs[_i];
            name = attr.name;
            val = attr.val;
            if ('class' === name) {
              name = 'className';
            }
            if ('className' !== name && visited[name]) {
              throw new Error('Duplicate key ' + JSON.stringify(name) + ' is not allowed.');
            }
            visited[name] = true;
            if ('className' === name) {
              classExpressions.push(val);
            } else {
              normalized[name] = val;
            }
          }
          if (visited['className']) {
            normalized['className'] = normalizeClassExpressions(classExpressions);
          }
          return normalized;
        };
        visitAttributes = function(attrs, attributeBlocks) {
          var name, normalized, pairs, sep, val;
          if (!(attrs && attrs.length)) {
            bufferExpression('null');
            return;
          }
          normalized = normalizeAttributes(attrs);
          pairs = [];
          for (name in normalized) {
            val = normalized[name];
            pairs.push([name, val]);
          }
          pairs.sort(pairSort);
          if (pretty) {
            sep = ': ';
          } else {
            sep = ':';
          }
          pairs = pairs.map(function(pair) {
            name = pair[0], val = pair[1];
            return JSON.stringify(name) + sep + val;
          });
          bufferExpression('{');
          if (pretty) {
            depth += 2;
            bufferExpression('\n', indentToDepth());
            bufferExpression(pairs.join(',\n' + indentToDepth()));
            depth -= 1;
            bufferExpression('\n', indentToDepth());
            depth -= 1;
          } else {
            bufferExpression(pairs.join(','));
          }
          return bufferExpression('}');
        };
        visitCode = function(code) {
          if (!code) {
            return;
          }
          return bufferExpression(indentToDepth(), code.val);
        };
        visitText = function(node) {
          return bufferExpression(indentToDepth(), JSON.stringify(node.val));
        };
        visitEach = function(node) {
          var _i, _len, _ref;
          needsMap = true;
          depth += 1;
          bufferExpression(indentToDepth(), 'map(', node.obj);
          if (pretty) {
            bufferExpression(', function (');
          } else {
            bufferExpression(',function(');
          }
          bufferExpression(node.val);
          if (pretty) {
            bufferExpression(', ');
          } else {
            bufferExpression(',');
          }
          bufferExpression(node.key, ')');
          if (pretty) {
            bufferExpression(' {\n');
          } else {
            bufferExpression('{');
          }
          depth += 1;
          bufferExpression(indentToDepth(), 'return ');
          continueIndenting = false;
          _ref = node.block.nodes;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            node = _ref[_i];
            visit(node);
          }
          if (pretty) {
            bufferExpression(';\n');
          } else {
            bufferExpression(';');
          }
          depth -= 1;
          if (pretty) {
            bufferExpression(indentToDepth(), '}\n');
          } else {
            bufferExpression(indentToDepth(), '}');
          }
          depth -= 1;
          return bufferExpression(indentToDepth(), ')');
        };
        visitNodes = {
          Text: visitText,
          Tag: visitTag,
          Block: visitBlock,
          Each: visitEach,
          Code: visitCode,
          Doctype: function() {
            throw new Error('Component may not have doctype tag');
          }
        };
        indentToDepth = function() {
          if (!pretty) {
            return '';
          }
          if (continueIndenting) {
            return Array(depth + 3).join('  ');
          } else {
            continueIndenting = true;
            return '';
          }
        };
        bufferExpression = function() {
          var strs;
          strs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return parts = parts.concat(strs);
        };
        visit = function(node) {
          return visitNodes[node.type](node);
        };
        visit(node);
        if (pretty) {
          parts.unshift('  return ');
          if (needsMap) {
            parts.unshift(prettyMap);
          }
          parts.unshift('function () {\n');
        } else {
          parts.unshift('return ');
          if (needsMap) {
            parts.unshift(terseMap);
          }
          parts.unshift('function(){');
        }
        if (pretty) {
          bufferExpression(';\n}\n');
        } else {
          bufferExpression(';}');
        }
        toPush = function(part) {
          return 'buf.push(' + JSON.stringify(part) + ');';
        };
        return parts.map(toPush).join('\n');
      }
    };
  };

  module.exports = Compiler;

}).call(this);
